<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kaizen Platform on (rudolph-miller)</title>
    <link>https://blog.rudolph-miller.com/tags/kaizen-platform/</link>
    <description>Recent content in Kaizen Platform on (rudolph-miller)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <copyright>&amp;copy; 2015 Rudolph Miller</copyright>
    <lastBuildDate>Sun, 31 Jan 2016 21:39:15 +0900</lastBuildDate>
    <atom:link href="https://blog.rudolph-miller.com/tags/kaizen-platform/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>detect-js-changes</title>
      <link>https://blog.rudolph-miller.com/2016/01/31/detect-js-changes/</link>
      <pubDate>Sun, 31 Jan 2016 21:39:15 +0900</pubDate>
      
      <guid>https://blog.rudolph-miller.com/2016/01/31/detect-js-changes/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/Rudolph-Miller/detect-js-changes&#34;&gt;detect-js-changes&lt;/a&gt;という業務Toolを作ってKaizenの業務をKAIZENした話.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#background:344e738fbd9ca3a556971580ada8f1e4&#34;&gt;Background&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#detect-js-changes:344e738fbd9ca3a556971580ada8f1e4&#34;&gt;detect-js-changes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go:344e738fbd9ca3a556971580ada8f1e4&#34;&gt;Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#see-also:344e738fbd9ca3a556971580ada8f1e4&#34;&gt;See Also&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;background:344e738fbd9ca3a556971580ada8f1e4&#34;&gt;Background&lt;/h1&gt;

&lt;h2 id=&#34;javascript-file:344e738fbd9ca3a556971580ada8f1e4&#34;&gt;JavaScript file&lt;/h2&gt;

&lt;p&gt;Kaizen PlatformではAB TestのJavaScript fileをBaseのfileにClient毎のDataを書き出して生成している.
生成後、JavaScript fileをClient毎のS3 ObjectにUploadしている.&lt;/p&gt;

&lt;h2 id=&#34;e2e:344e738fbd9ca3a556971580ada8f1e4&#34;&gt;E2E&lt;/h2&gt;

&lt;p&gt;このAB TestのJavaScriptに対してPhantomJSやBrowserStack上でのE2E Testを行っている.&lt;/p&gt;

&lt;p&gt;DeployのタイミングでこのE2E Testを実施しているのだが、
そもそも生成されるJavaScript fileに変更がなかった場合Test結果は変わらないのでskipすることになっている.&lt;/p&gt;

&lt;h2 id=&#34;until-now:344e738fbd9ca3a556971580ada8f1e4&#34;&gt;Until now&lt;/h2&gt;

&lt;p&gt;このJavaScript fileに変更があるかないかの確認フローは、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;今までは対象のJavaScript files (16 files) のURLに対して &lt;code&gt;wget&lt;/code&gt; .&lt;/li&gt;
&lt;li&gt;Depoly.&lt;/li&gt;
&lt;li&gt;再度 &lt;code&gt;wget&lt;/code&gt; .&lt;/li&gt;
&lt;li&gt;末尾にJavaScript file生成日時のTimestampと、ClientのDataに書き出した日時のTimestampがあるので、それら意外に差分がないかを &lt;code&gt;diff&lt;/code&gt; で確認.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となっていて、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;何回も &lt;code&gt;wget&lt;/code&gt; する.

&lt;ul&gt;
&lt;li&gt;Deploy環境によってURLが変わる. (QA用やProduction用など.)&lt;/li&gt;
&lt;li&gt;Timestampの差分すら出なかった場合はS3の反映待ちだったりするので、再度 &lt;code&gt;wget&lt;/code&gt; する.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;JavaScript fileはminifyしてあるので、&lt;code&gt;diff&lt;/code&gt; をとるにはunminifyしないといけない.&lt;/li&gt;
&lt;li&gt;Timestampの差分はでるので、 &lt;code&gt;diff&lt;/code&gt; の結果をTimestampの差分かどうか確認しないといけない.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;あたりが面倒くさい.&lt;/p&gt;

&lt;p&gt;ひとつひとつのStepはScriptが用意されていたりするが、それでも面倒くさい.&lt;/p&gt;

&lt;p&gt;Depoly (基本は週2回) 毎にこれを誰かが実行している.&lt;/p&gt;

&lt;h1 id=&#34;detect-js-changes:344e738fbd9ca3a556971580ada8f1e4&#34;&gt;detect-js-changes&lt;/h1&gt;

&lt;p&gt;この面倒くささを解消するために作ったのが &lt;code&gt;detect-js-changes&lt;/code&gt; だ.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ go get github.com/Rudolph-Miller/detect-js-changes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でinstallできる.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;detect-js-changes&lt;/code&gt; を使うと上の確認フローが、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;detect-js-changes download&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Deploy.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;detect-js-changes download&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;detect-js-changes detect&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となる.&lt;/p&gt;

&lt;p&gt;Deploy環境ごとのURLは &lt;code&gt;config.yml&lt;/code&gt; に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;qa:
  urls:
  - https://qa.kaizenplatform.com/file1.js
  - https://qa.kaizenplatform.com/file2.js
production:
  urls:
  - https://production.kaizenplatform.com/file1.js
  - https://production.kaizenplatform.com/file2.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とYAMLで記述し、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;detect-js-changes -e qa -c config.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と環境やConfig fileを指定できる.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;config.yml&lt;/code&gt; でどういうKeywordをignoreするか
(今回は末尾のTimestampとClientのDataのTimestampを特定するKeyword)
も指定できる.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;default:
  ignore_keywords:
  - Timestamp
  - generated_at
qa:
  urls:
  - https://qa.kaizenplatform.com/file1.js
  - https://qa.kaizenplatform.com/file2.js
production:
  urls:
  - https://production.kaizenplatform.com/file1.js
  - https://production.kaizenplatform.com/file2.js
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;go:344e738fbd9ca3a556971580ada8f1e4&#34;&gt;Go&lt;/h1&gt;

&lt;p&gt;軽く実装に触れておく.&lt;/p&gt;

&lt;p&gt;言語は &lt;code&gt;Go&lt;/code&gt; を使用しており、採用理由はなんとなくである.&lt;/p&gt;

&lt;h2 id=&#34;cli:344e738fbd9ca3a556971580ada8f1e4&#34;&gt;CLI&lt;/h2&gt;

&lt;p&gt;CLIには &lt;a href=&#34;https://github.com/codegangsta/cli&#34;&gt;&lt;code&gt;codegangsta/cli&lt;/code&gt;&lt;/a&gt; を使用した.&lt;/p&gt;

&lt;p&gt;感想は特にない.&lt;/p&gt;

&lt;h2 id=&#34;yaml:344e738fbd9ca3a556971580ada8f1e4&#34;&gt;YAML&lt;/h2&gt;

&lt;p&gt;YAML formatのConfig fileのparseには &lt;a href=&#34;https://github.com/go-yaml/yaml&#34;&gt;gopkg.in/yaml.v2&lt;/a&gt; を使用した.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;gopkg.in/yaml.v2&amp;quot;
  &amp;quot;os&amp;quot;
)

var data = `
key1: value1
key2:
  key3:
  - value2
  - value3
`

type T struct {
  Key1 string
  Key2 struct {
    Key3 []string
  }
}

func main() {
  t := T{}
  err := yaml.Unmarshal([]byte(data), &amp;amp;t)
  if err != nil {
    fmt.Println(err)
    os.Exit(1)
  }

  fmt.Println(t)
  // {value1 {[value2 value3]}}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;の様にOutputの &lt;code&gt;struct&lt;/code&gt; を用意して &lt;code&gt;yaml.Unmarshal&lt;/code&gt; するのだが、今回のConfig fileは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;default:
  ignore_keywords:
  - sample keyword
development:
  urls:
  - https://development.kaizenplatform.com/file0.js
  - https://development.kaizenplatform.com/file1.js
production:
  urls:
  - https://production.kaizenplatform.com/file0.js
  - https://production.kaizenplatform.com/file1.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;の様に環境名がTop levelのKeyとなりその下に特定のKVが入る形式で、
環境名はUserが自由に指定でき、Top levelのKeyが指定できない.&lt;/p&gt;

&lt;p&gt;この場合は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;gopkg.in/yaml.v2&amp;quot;
  &amp;quot;os&amp;quot;
)

var data = `
default:
  key1: value1
  key2:
    key3:
    - value2
    - value3
development:
  key1: value1
  key2:
    key3:
    - value2
    - value3
`

type T struct {
  Key1 string
  Key2 struct {
    Key3 []string
  }
}

func main() {
  m := make(map[string]T)
  err := yaml.Unmarshal([]byte(data), &amp;amp;m)
  if err != nil {
    fmt.Println(err)
    os.Exit(1)
  }

  fmt.Println(m)
  // map[default:{value1 {[value2 value3]}} development:{value1 {[value2 value3]}}]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;の様に &lt;code&gt;map&lt;/code&gt; で指定する.&lt;/p&gt;

&lt;h2 id=&#34;unminify:344e738fbd9ca3a556971580ada8f1e4&#34;&gt;Unminify&lt;/h2&gt;

&lt;p&gt;minified fileのunminifyには &lt;a href=&#34;https://github.com/ditashi/jsbeautifier-go&#34;&gt;&lt;code&gt;ditashi/jsbeautifier-go&lt;/code&gt;&lt;/a&gt; と言う &lt;a href=&#34;http://jsbeautifier.org&#34;&gt;jsbeautifier&lt;/a&gt; のGo port (CLI tool) の内部APIを使用した.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function main(){var e={key1:&amp;quot;value1&amp;quot;,key2:{key3:[&amp;quot;value2&amp;quot;,&amp;quot;value3&amp;quot;]}};console.log(e)}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;の様なminifiedなJavaScriptを &lt;code&gt;example.min.js&lt;/code&gt; として用意して、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;github.com/ditashi/jsbeautifier-go/jsbeautifier&amp;quot;
)

func beautify(src string) *string {
  options := jsbeautifier.DefaultOptions()
  return jsbeautifier.BeautifyFile(src, options)
}

func main() {
  filename := &amp;quot;example.min.js&amp;quot;
  fmt.Println(*beautify(filename))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を &lt;code&gt;go run&lt;/code&gt; すると、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function main() {
    var e = {
        key1: &amp;quot;value1&amp;quot;,
        key2: {
            key3: [&amp;quot;value2&amp;quot;, &amp;quot;value3&amp;quot;]
        }
    };
    console.log(e)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とunminifyできる.&lt;/p&gt;

&lt;h2 id=&#34;diff:344e738fbd9ca3a556971580ada8f1e4&#34;&gt;Diff&lt;/h2&gt;

&lt;p&gt;diffには &lt;a href=&#34;https://github.com/sergi/go-diff&#34;&gt;sergi/go-diff/diffmatchpatch&lt;/a&gt; を使用した.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;github.com/sergi/go-diff/diffmatchpatch&amp;quot;
  &amp;quot;strings&amp;quot;
)

func lineDiff(src1, src2 string) []diffmatchpatch.Diff {
  dmp := diffmatchpatch.New()
  a, b, c := dmp.DiffLinesToChars(src1, src2)
  diffs := dmp.DiffMain(a, b, false)
  result := dmp.DiffCharsToLines(diffs, c)
  return result
}

func prefix(diff diffmatchpatch.Diff) string {
  switch diff.Type {
  case diffmatchpatch.DiffEqual:
    return &amp;quot; &amp;quot;
  case diffmatchpatch.DiffInsert:
    return &amp;quot;+&amp;quot;

  case diffmatchpatch.DiffDelete:
    return &amp;quot;-&amp;quot;
  }
  return &amp;quot; &amp;quot;
}

var src1 = `
abc
def
ghi
`

var src2 = `
abc
defg
hi
`

func main() {
  result := lineDiff(src1, src2)

  for _, diff := range result {
    for _, string := range strings.Split(diff.Text, &amp;quot;\n&amp;quot;) {
      if len(string) &amp;gt; 0 {
        fmt.Println(prefix(diff) + string)
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を &lt;code&gt;go run&lt;/code&gt; すると、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; abc
-def
-ghi
+defg
+hi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となり、行単位のdiffが取れている.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;業務KAIZEN! ╭( ･ㅂ･)و&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&#34;see-also:344e738fbd9ca3a556971580ada8f1e4&#34;&gt;See Also&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Rudolph-Miller/detect-js-changes&#34;&gt;detect-js-changes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/codegangsta/cli&#34;&gt;codegangsta/cli&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/go-yaml/yaml&#34;&gt;gopkg.in/yaml.v2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ditashi/jsbeautifier-go&#34;&gt;ditashi/jsbeautifier-go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/sergi/go-diff&#34;&gt;sergi/go-diff/diffmatchpatch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Import Query Result to BigQuery</title>
      <link>https://blog.rudolph-miller.com/2016/01/15/import-query-result-to-bigquery/</link>
      <pubDate>Fri, 15 Jan 2016 18:45:16 +0900</pubDate>
      
      <guid>https://blog.rudolph-miller.com/2016/01/15/import-query-result-to-bigquery/</guid>
      <description>

&lt;p&gt;特定DirectoryにあるSQL fileを実行して、結果をBigQueryに入れるScriptを書いた.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#background:139eb9a18c43f6f61ff0332b901ae2a9&#34;&gt;Background&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#import-query-result-to-bigquery:139eb9a18c43f6f61ff0332b901ae2a9&#34;&gt;Import Query Result to BigQuery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#see-also:139eb9a18c43f6f61ff0332b901ae2a9&#34;&gt;See Also&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;background:139eb9a18c43f6f61ff0332b901ae2a9&#34;&gt;Background&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://kaizenplatform.com/ja/&#34;&gt;Kaizen Platform&lt;/a&gt;では&lt;a href=&#34;https://cloud.google.com/bigquery/?hl=ja&#34;&gt;BigQuery&lt;/a&gt;と&lt;a href=&#34;http://redash.io/&#34;&gt;re:dash&lt;/a&gt;を使ってProjectの&lt;strong&gt;定量KPIの可視化&lt;/strong&gt;をしていて、定期的に振り返りの機会を設けている.&lt;/p&gt;

&lt;p&gt;これを実施・運用する上で困ったのが、UserのPVなどをplotする際に社内のUserかどうかがBigQueryに格納しているDataだけでは判別がつかないことだった.&lt;br /&gt;
(社内UserのIDリストを &lt;code&gt;user_id NOT IN (...)&lt;/code&gt; に貼り付けるという&lt;strong&gt;真心こもったOperation&lt;/strong&gt;が行われていた.)&lt;/p&gt;

&lt;p&gt;Kaizen Platformでは数ヶ月に一度 &lt;code&gt;Kaizen Week&lt;/code&gt; の名で、日頃のプロジェクトを一時停止して、積みタスクや、リファクタリング、新しいツールの試験・導入などの時間を確保しようという試みがあり、ちょうど今週がその &lt;code&gt;Kaizen Week&lt;/code&gt; だったので、ここを改善しようと思った.&lt;/p&gt;

&lt;p&gt;解決策としては2通り考えられる.
一つがLogにUserの属性を埋め込む方法、もう一つはBigQuery外部のDatabase (今回は社内のMySQL) からUserの属性を参照する方法だが、今回は二つ目の方法をとることにした.&lt;/p&gt;

&lt;p&gt;外部DatabaseをBigQueryから参照する方法だが、Query Engineでうまい具合にJOINする方法 (&lt;a href=&#34;https://prestodb.io/&#34;&gt;Presto&lt;/a&gt;) と、外部DatabaseのDataをBigQueryにimportする方法が考えられた. 一つ目の方法はこれぐらい軽いことをやりるのにわざわさ導入するのはなって気がした (あくまで気がした) ので、外部DatabaseのDataをBigQueryにimportすることにした.&lt;/p&gt;

&lt;p&gt;今回の場合、とりあえずUserのTableをうまい具合にBigQueryにimportするだけで良かったが、今後もカジュアルに外部DatabaseのDataをBigQueryにimportしたいという要望があったので、&lt;strong&gt;特定の場所にSQL fileを配置するだけで、それらを実行した結果をBigQueryにimportできる&lt;/strong&gt;ようにした.&lt;/p&gt;

&lt;h1 id=&#34;import-query-result-to-bigquery:139eb9a18c43f6f61ff0332b901ae2a9&#34;&gt;Import Query Result to BigQuery&lt;/h1&gt;

&lt;h2 id=&#34;how:139eb9a18c43f6f61ff0332b901ae2a9&#34;&gt;How&lt;/h2&gt;

&lt;p&gt;始めはGoでScriptを書いていたが、ふとEmbulkが使えないかと思って調べてみると、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MySQLのInput pluginとBigQueryのOutput pluginは当然ある.&lt;/li&gt;
&lt;li&gt;MySQLのInput pluginで任意のQueryが実行できる.&lt;/li&gt;
&lt;li&gt;Queryの実行結果に対応するSchemaからBigQueryのSchemaを生成できると良かったが (別でPlugin書けばできそう) 、今回はSQL fileと別に &lt;code&gt;.schema.json&lt;/code&gt; でBigQueryのSchemaを用意することにする.&lt;/li&gt;
&lt;li&gt;Configulation fileのExtensionを &lt;code&gt;liquid&lt;/code&gt; にすると&lt;a href=&#34;http://liquidmarkup.org/&#34;&gt;Liquid Template Engine&lt;/a&gt;が使用できる.

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;env&lt;/code&gt; によって外部から値を差し込むことが可能.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;だったので、Scriptの中で特定の場所にあるSQL fileをとってきて、その情報で &lt;code&gt;env&lt;/code&gt; を差し替えることにより、QueryそれぞれでConfigulation fileを作成する必要がなく、Embulkで上の目標が達成できそうだったので、Embulkを採用することにした.&lt;/p&gt;

&lt;h2 id=&#34;do-it:139eb9a18c43f6f61ff0332b901ae2a9&#34;&gt;Do it&lt;/h2&gt;

&lt;p&gt;Embulkはinstall済みだとして、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ embulk gem install embulk-input-mysql
$ embulk gem install embulk-output-bigquery
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、今回必要なPluginsをinstallする.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;in:
  type: mysql
  host: {{ env.mysql_host }}
  user: {{ env.mysql_user }}
  {% if env.mysql_password %}
    password: {{ env.mysql_password }}
  {% endif %}
  database:  {{ env.mysql_database }}
  query: {{ env.query }}
out:
  type: bigquery
  file_ext: csv
  auth_method: private_key
  service_account_email: {{ env.service_account_email }}
  p12_keyfile: {{ env.p12_keyfile }}
  path_prefix: /tmp/import_query_result_to_bq/
  file_ext: csv
  delete_from_local_when_job_end: 1
  project: your_project
  dataset: {{ env.dataset }}
  table: {{ env.table }}_%Y%m%d
  source_format: CSV
  formatter:
    type: csv
    header_line: false
  schema_file: {{ env.schema_file }}
  auto_create_table: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように &lt;code&gt;Liquid Template Engine&lt;/code&gt; を使用し &lt;code&gt;env&lt;/code&gt; で設定可能な &lt;code&gt;config.yml.liquid&lt;/code&gt; を用意し、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash

QUERY_DIR=query
DATASET=tmp

export service_account_email=example@developer.gserviceaccount.com
export p12_keyfile=/path/to/p12_keyfile.p12

export mysql_host=localhost
export mysql_user=root
export mysql_password=password
export mysql_database=your_database
export dataset=$DATASET

for file in $QUERY_DIR/*.sql; do
  export query=`cat $file`
  filename=${file##*/}
  basename=${filename%.*}
  dir=$(cd $(dirname $file) &amp;amp;&amp;amp; pwd)
  export table=$basename
  export schema_file=$dir/$basename.schema.json
  embulk run config.yml.liquid
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようなScriptを &lt;code&gt;import_query_result_to_bigquery&lt;/code&gt; として用意し実行権限をつけ、 &lt;code&gt;QUERY_DIR&lt;/code&gt; に設定したDirectoryに、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT id FROM users WHENE is_admin = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を &lt;code&gt;admin_users.sql&lt;/code&gt; として、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
  { &amp;quot;name&amp;quot;: &amp;quot;id&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;STRING&amp;quot; }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を &lt;code&gt;admin_users.schema.json&lt;/code&gt; として配置し、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ ./import_query_result_to_bigquery
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行すると、 &lt;code&gt;admin_users.sql&lt;/code&gt; のQueryの実行結果を &lt;code&gt;DATASET&lt;/code&gt; で設定したBigQueryのDatasetにTable名 &lt;code&gt;admin_users_20160114&lt;/code&gt; (PrefixはSQL file名で、Suffixは年月日) としてimportできる.&lt;/p&gt;

&lt;h2 id=&#34;operation:139eb9a18c43f6f61ff0332b901ae2a9&#34;&gt;Operation&lt;/h2&gt;

&lt;h3 id=&#34;query-files:139eb9a18c43f6f61ff0332b901ae2a9&#34;&gt;Query files&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;*.sql&lt;/code&gt; と &lt;code&gt;*.schema.json&lt;/code&gt; は専用のGitHubのRepositioryを作成して、そこに集約し、Scriptの実行前に &lt;code&gt;QUERY_DIR&lt;/code&gt; で指定したDirectoryに展開する.&lt;/p&gt;

&lt;p&gt;これによって、新しくQueryを追加する際に、&lt;strong&gt;GitHub上で完結&lt;/strong&gt;できる.&lt;/p&gt;

&lt;h3 id=&#34;query-in-bigquery:139eb9a18c43f6f61ff0332b901ae2a9&#34;&gt;Query in BigQuery&lt;/h3&gt;

&lt;p&gt;cronなどでDailyのJobとして実行するとして、Table名のSuffixとして &lt;code&gt;_%Y%m%d&lt;/code&gt; がついているので、BigQuery上では &lt;code&gt;TABLE_DATE_RANGE&lt;/code&gt; を使用して、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT * FROM TABLE_DATE_RANGE(tmp.admin_users_, DATE_ADD(CURRENT_TIMESTAMP(), -1, &#39;DAY&#39;), CURRENT_TIMESTAMP());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにすると、当日のTableを対象としてQueryを実行できる.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;EmbulkのPlugin機構と &lt;code&gt;Liquid Template Engine&lt;/code&gt; のおかげで簡単なScriptで業務が改善した.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;see-also:139eb9a18c43f6f61ff0332b901ae2a9&#34;&gt;See Also&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/embulk/embulk&#34;&gt;Embulk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/embulk/embulk-input-jdbc/tree/master/embulk-input-mysql&#34;&gt;embulk-input-mysql&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/embulk/embulk-output-bigquery&#34;&gt;embulk-output-bigquery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://liquidmarkup.org/&#34;&gt;Liquid Template Engine&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>